1       /*--------------------------------------------------------------------*/
2       /* bdt.c (1st bad version)                                            */
3       /* Author: Christopher Moretti                                        */
4       /*--------------------------------------------------------------------*/
5
6       #include <stddef.h>
7       #include <assert.h>
8       #include <string.h>
9       #include <stdio.h>
10      #include <stdlib.h>
(gdb) list
11
12      #include "dynarray.h"
13      #include "path.h"
14      #include "bdt.h"
15
16
17      /* A node in a BDT */
18      struct node {
19         /* the object corresponding to the node's absolute path */
20         Path_T oPPath;
(gdb) list
21         /* this node's parent */
22         struct node *psParent;
23         /* this node's children */
24         struct node *psChild1, *psChild2;
25      };
26
27      /*
28        A Directory Tree is a representation of a hierarchy of directories,
29        represented as an AO with 3 state variables:
30      */
(gdb) list
31
32      /* 1. a flag for being in an initialized state (TRUE) or not (FALSE) */
33      static boolean bIsInitialized;
34      /* 2. a pointer to the root node in the hierarchy */
35      static struct node *psRoot;
36      /* 3. a counter of the number of nodes in the hierarchy */
37      static size_t ulCount;
38
39      /*
40        Links new child psChild from psParent. If psParent already has
(gdb) list
41        two children, returns CONFLICTING_PATH, otherwise returns SUCCESS.
42      */
43      static int BDT_addChild(struct node *psParent, struct node *psChild) {
44         assert(psParent != NULL);
45         assert(psChild != NULL);
46
47         if(!psParent->psChild1)
48            psParent->psChild1 = psChild;
49         else if(!psParent->psChild2)
50            psParent->psChild2 = psChild;
(gdb) list
51         else
52            return CONFLICTING_PATH;
53
54         return SUCCESS;
55      }
56
57      /*
58        Compares the string representation of psfirst with a string
59        pcSecond representing a node's path.
60        Returns <0, 0, or >0 if psFirst is "less than", "equal to", or
(gdb) list
61        "greater than" pcSecond, respectively.
62      */
63      static int BDT_compareNodeToString(const struct node *psFirst,
64                                       const char *pcSecond) {
65         assert(psFirst != NULL);
66         assert(pcSecond != NULL);
67
68         return Path_compareString(psFirst->oPPath, pcSecond);
69      }
70
(gdb) list
71      /* Returns the number of children that psParent has. */
72      static size_t BDT_getNumChildren(struct node *psParent) {
73         assert(psParent != NULL);
74
75         return (size_t) (2 - (!psParent->psChild1 + !psParent->psChild2));
76      }
77
78      /*
79        Returns TRUE if psParent has a child with path oPPath. Returns
80        FALSE if it does not.
(gdb) list
81
82        If psParent has such a child, stores in *pulChildID the child's
83        identifier (as used in BDT_getChild). If psParent does not have
84        such a child, stores in *pulChildID the identifier that such a
85        child _would_ have if inserted.
86      */
87      static boolean BDT_hasChild(struct node *psParent, Path_T oPPath,
88                               size_t *pulChildID) {
89         assert(psParent != NULL);
90         assert(oPPath != NULL);
(gdb) list
91         assert(pulChildID != NULL);
92
93         if(!psParent->psChild1) {
94            *pulChildID = 0;
95            return FALSE;
96         }
97         else if(!BDT_compareNodeToString(psParent->psChild1,
98                                     Path_getPathname(oPPath))) {
99            *pulChildID = 0;
100           return TRUE;
(gdb) list
101        }
102        else if(!psParent->psChild2) {
103           *pulChildID = 1;
104           return FALSE;
105        }
106        else if(!BDT_compareNodeToString(psParent->psChild2,
107                                    Path_getPathname(oPPath))) {
108           *pulChildID = 1;
109           return TRUE;
110        }
(gdb) list
111        else {
112           *pulChildID = 2;
113           return FALSE;
114        }
115     }
116
117
118     /*
119       Creates a new node with path oPPath and parent psParent.  Returns an
120       int SUCCESS status and sets *ppsResult to be the new node if
(gdb) list
121       successful. Otherwise, sets *ppsResult to NULL and returns status:
122       * MEMORY_ERROR if memory could not be allocated to complete request
123       * CONFLICTING_PATH if psParent's path is not an ancestor of oPPath
124                          or if psParent already has two children
125       * NO_SUCH_PATH if oPPath is of depth 0
126                      or psParent's path is not oPPath's direct parent
127                      or psParent is NULL but oPPath is not of depth 1
128       * ALREADY_IN_TREE if psParent already has a child with this path
129     */
130     static int BDT_newNode(Path_T oPPath, struct node *psParent, struct node **ppsResult) {
(gdb) list
131        struct node *psNew;
132        Path_T oPParentPath = NULL;
133        Path_T oPNewPath = NULL;
134        size_t ulParentDepth;
135        size_t ulIndex;
136        int iStatus;
137
138        assert(oPPath != NULL);
139        assert(ppsResult != NULL);
140        /* psParent may be NULL -- when the new node is the root */
(gdb) list
141
142        /* allocate space for a new node */
143        psNew = malloc(sizeof(struct node));
144        if(psNew == NULL) {
145           *ppsResult = NULL;
146           return MEMORY_ERROR;
147        }
148
149        /* set the new node's path */
150        iStatus = Path_dup(oPPath, &oPNewPath);
(gdb) list
151        if(iStatus != SUCCESS) {
152           free(psNew);
153           *ppsResult = NULL;
154           return iStatus;
155        }
156        psNew->oPPath = oPNewPath;
157
158        /* validate and set the new node's parent */
159        if(psParent != NULL) {
160           size_t ulSharedDepth;
(gdb) list
161
162           oPParentPath = psParent->oPPath;
163           ulParentDepth = Path_getDepth(oPParentPath);
164           ulSharedDepth = Path_getSharedPrefixDepth(psNew->oPPath,
165                                                     oPParentPath);
166           /* parent must be an ancestor of child */
167           if(ulSharedDepth < ulParentDepth) {
168              Path_free(psNew->oPPath);
169              free(psNew);
170              *ppsResult = NULL;
(gdb) list
171              return CONFLICTING_PATH;
172           }
173
174           /* parent must be exactly one level up from child */
175           if(Path_getDepth(psNew->oPPath) != ulParentDepth + 1) {
176              Path_free(psNew->oPPath);
177              free(psNew);
178              *ppsResult = NULL;
179              return NO_SUCH_PATH;
180           }
(gdb) list
181
182           /* parent must not already have child with this path */
183           if(BDT_hasChild(psParent, oPPath, &ulIndex)) {
184              Path_free(psNew->oPPath);
185              free(psNew);
186              *ppsResult = NULL;
187              return ALREADY_IN_TREE;
188           }
189
190           /* parent must not already have two children */
(gdb) list
191           if(BDT_getNumChildren(psParent) == 2) {
192              Path_free(psNew->oPPath);
193              free(psNew);
194              *ppsResult = NULL;
195              return CONFLICTING_PATH;
196           }
197        }
198        else {
199           /* new node must be root */
200           /* can only create one "level" at a time */
(gdb) list
201           if(Path_getDepth(psNew->oPPath) != 1) {
202              Path_free(psNew->oPPath);
203              free(psNew);
204              *ppsResult = NULL;
205              return NO_SUCH_PATH;
206           }
207        }
208        psNew->psParent = psParent;
209
210        /* set the new node's children */
(gdb) list
211        psNew->psChild1 = NULL;
212        psNew->psChild2 = NULL;
213
214        /* Link into parent's child link */
215        if(psParent != NULL) {
216           iStatus = BDT_addChild(psParent, psNew);
217           if(iStatus != SUCCESS) {
218              Path_free(psNew->oPPath);
219              free(psNew);
220              *ppsResult = NULL;
(gdb) list
221              return iStatus;
222           }
223        }
224
225        *ppsResult = psNew;
226        return SUCCESS;
227     }
228
229     /*
230       Destroys and frees all memory allocated for the subtree rooted at
(gdb) list
231       psNode, i.e., deletes this node and all its descendents. Returns the
232       number of nodes deleted.
233     */
234     static size_t BDT_freeSubtree(struct node *psNode) {
235        size_t ulCount = 0;
236
237        assert(psNode != NULL);
238
239        /* remove from parent's list */
240        if(psNode->psParent != NULL) {
(gdb) list
241           if(psNode->psParent->psChild1 == psNode) {
242              psNode->psParent->psChild1 = psNode->psParent->psChild2;
243              psNode->psParent->psChild2 = NULL;
244           }
245           else if(psNode->psParent->psChild2 == psNode) {
246              psNode->psParent->psChild2 = NULL;
247           }
248           else {
249              assert(FALSE);
250           }
(gdb) list
251        }
252
253        /* recursively remove children */
254        if(psNode->psChild2)
255           ulCount += BDT_freeSubtree(psNode->psChild2);
256        if(psNode->psChild1)
257           ulCount += BDT_freeSubtree(psNode->psChild1);
258
259        /* remove path */
260        Path_free(psNode->oPPath);
(gdb) list
261
262        /* finally, free the struct node */
263        free(psNode);
264        ulCount++;
265        return ulCount;
266     }
267
268     /* Returns the path object representing psNode's absolute path. */
269     static Path_T BDT_getPath(struct node *psNode) {
270        assert(psNode != NULL);
(gdb) list
271
272        return psNode->oPPath;
273     }
274
275
276     /*
277       Returns an int SUCCESS status and sets *ppsResult to be the child
278       node of psParent with identifier ulChildID, if one exists.
279       Otherwise, sets *ppsResult to NULL and returns status:
280       * NO_SUCH_PATH if ulChildID is not a valid child for psParent
(gdb) list
281     */
282     static int  BDT_getChild(struct node *psParent, size_t ulChildID,
283                        struct node **ppsResult) {
284
285        assert(psParent != NULL);
286        assert(ppsResult != NULL);
287
288        if(ulChildID == 0) {
289           *ppsResult = psParent->psChild1;
290           if(*ppsResult) return SUCCESS;
(gdb) list
291           else return NO_SUCH_PATH;
292        }
293        else if(ulChildID == 1) {
294           *ppsResult = psParent->psChild2;
295           if(*ppsResult) return SUCCESS;
296           else return NO_SUCH_PATH;
297        }
298        else {
299           *ppsResult = NULL;
300           return NO_SUCH_PATH;
(gdb) list
301        }
302     }
303
304     /* --------------------------------------------------------------------
305
306       The BDT_traversePath and BDT_findNode functions modularize the common
307       functionality of going as far as possible down an BDT towards a path
308       and returning either the node of however far was reached or the
309       node if the full path was reached, respectively.
310     */
(gdb) list
311
312     /*
313       Traverses the BDT starting at the root as far as possible towards
314       absolute path oPPath. If able to traverse, returns an int SUCCESS
315       status and sets *ppsFurthest to the furthest node reached (which may
316       be only a prefix of oPPath, or even NULL if the root is NULL).
317       Otherwise, sets *ppsFurthest to NULL and returns with status:
318       * CONFLICTING_PATH if the root's path is not a prefix of oPPath
319       * MEMORY_ERROR if memory could not be allocated to complete request
320     */
(gdb) list
321     static int BDT_traversePath(Path_T oPPath, struct node **ppsFurthest) {
322        int iStatus;
323        Path_T oPPrefix = NULL;
324        struct node *psCurr;
325        struct node *psChild = NULL;
326        size_t ulDepth;
327        size_t i;
328        size_t ulChildID;
329
330        assert(oPPath != NULL);
(gdb) list
331        assert(ppsFurthest != NULL);
332
333        /* root is NULL -> won't find anything */
334        if(psRoot == NULL) {
335           *ppsFurthest = NULL;
336           return SUCCESS;
337        }
338
339        iStatus = Path_prefix(oPPath, 1, &oPPrefix);
340        if(iStatus != SUCCESS) {
(gdb) list
341           *ppsFurthest = NULL;
342           return iStatus;
343        }
344
345        if(Path_comparePath(BDT_getPath(psRoot), oPPrefix)) {
346           Path_free(oPPrefix);
347           *ppsFurthest = NULL;
348           return CONFLICTING_PATH;
349        }
350        Path_free(oPPrefix);
(gdb) list
351        oPPrefix = NULL;
352
353        psCurr = psRoot;
354        ulDepth = Path_getDepth(oPPath);
355        for(i = 2; i <= ulDepth; i++) {
356           iStatus = Path_prefix(oPPath, i, &oPPrefix);
357           if(iStatus != SUCCESS) {
358              *ppsFurthest = NULL;
359              return iStatus;
360           }
(gdb) list
361           if(BDT_hasChild(psCurr, oPPrefix, &ulChildID)) {
362              /* go to that child and continue with next prefix */
363              Path_free(oPPrefix);
364              oPPrefix = NULL;
365              iStatus = BDT_getChild(psCurr, ulChildID, &psChild);
366              if(iStatus != SUCCESS) {
367                 *ppsFurthest = NULL;
368                 return iStatus;
369              }
370              psCurr = psChild;
(gdb) list
371           }
372           else {
373              /* psCurr doesn't have child with path oPPrefix:
374                 this is as far as we can go */
375              break;
376           }
377        }
378
379        Path_free(oPPrefix);
380        *ppsFurthest = psCurr;
(gdb) list
381        return SUCCESS;
382     }
383
384     /*
385       Traverses the BDT to find a node with absolute path pcPath. Returns a
386       int SUCCESS status and sets *ppsResult to be the node, if found.
387       Otherwise, sets *ppsResult to NULL and returns with status:
388       * INITIALIZATION_ERROR if the BDT is not in an initialized state
389       * BAD_PATH if pcPath does not represent a well-formatted path
390       * CONFLICTING_PATH if the root's path is not a prefix of pcPath
(gdb) list
391       * NO_SUCH_PATH if no node with pcPath exists in the hierarchy
392       * MEMORY_ERROR if memory could not be allocated to complete request
393      */
394     static int BDT_findNode(const char *pcPath, struct node **ppsResult) {
395        Path_T oPPath = NULL;
396        struct node *psFound = NULL;
397        int iStatus;
398
399        assert(pcPath != NULL);
400        assert(ppsResult != NULL);
(gdb) list
401
402        if(!bIsInitialized) {
403           *ppsResult = NULL;
404           return INITIALIZATION_ERROR;
405        }
406
407        iStatus = Path_new(pcPath, &oPPath);
408        if(iStatus != SUCCESS) {
409           *ppsResult = NULL;
410           return iStatus;
(gdb) list
411        }
412
413        iStatus = BDT_traversePath(oPPath, &psFound);
414        if(iStatus != SUCCESS)
415        {
416           Path_free(oPPath);
417           *ppsResult = NULL;
418           return iStatus;
419        }
420
(gdb) list
421        if(psFound == NULL) {
422           Path_free(oPPath);
423           *ppsResult = NULL;
424           return NO_SUCH_PATH;
425        }
426
427        if(Path_comparePath(BDT_getPath(psFound), oPPath) != 0) {
428           Path_free(oPPath);
429           *ppsResult = NULL;
430           return NO_SUCH_PATH;
(gdb) list
431        }
432
433        Path_free(oPPath);
434        *ppsResult = psFound;
435        return SUCCESS;
436     }
437     /*--------------------------------------------------------------------*/
438
439
440     int BDT_insert(const char *pcPath) {
(gdb) list
441        int iStatus;
442        Path_T oPPath = NULL;
443        struct node *psFirstNew = NULL;
444        struct node *psCurr = NULL;
445        size_t ulDepth, ulIndex;
446        size_t ulNewNodes = 0;
447
448        assert(pcPath != NULL);
449
450        /* validate pcPath and generate a Path_T for it */
(gdb) list
451        iStatus = Path_new(pcPath, &oPPath);
452        if(iStatus != SUCCESS)
453           return iStatus;
454
455        /* find the closest ancestor of oPPath already in the tree */
456        iStatus= BDT_traversePath(oPPath, &psCurr);
457        if(iStatus != SUCCESS)
458        {
459           Path_free(oPPath);
460           return iStatus;
(gdb) list
461        }
462
463        /* no ancestor node found, so if root is not NULL,
464           pcPath isn't underneath root. */
465        if(psCurr == NULL && psRoot != NULL) {
466           Path_free(oPPath);
467           return CONFLICTING_PATH;
468        }
469
470        ulDepth = Path_getDepth(oPPath);
(gdb) list
471        if(psCurr == NULL) /* new root! */
472           ulIndex = 1;
473        else {
474           ulIndex = Path_getDepth(BDT_getPath(psCurr))+1;
475
476           /* psCurr is the node we're trying to insert */
477           if(ulIndex == ulDepth+1 && !Path_comparePath(oPPath,
478                                            BDT_getPath(psCurr))) {
479              Path_free(oPPath);
480              return ALREADY_IN_TREE;
(gdb) list
481           }
482        }
483
484        /* starting at psCurr, build rest of the path one level at a time */
485        while(ulIndex <= ulDepth) {
486           Path_T oPPrefix = NULL;
487           struct node *psNewNode = NULL;
488
489           /* generate a Path_T for this level */
490           iStatus = Path_prefix(oPPath, ulIndex, &oPPrefix);
(gdb) list
491           if(iStatus != SUCCESS) {
492              Path_free(oPPath);
493              if(psFirstNew != NULL)
494                 (void) BDT_freeSubtree(psFirstNew);
495              return iStatus;
496           }
497
498           /* insert the new node for this level */
499           iStatus = BDT_newNode(oPPrefix, psCurr, &psNewNode);
500           if(iStatus != SUCCESS) {
(gdb) list
501              Path_free(oPPath);
502              Path_free(oPPrefix);
503              if(psFirstNew != NULL)
504                 (void) BDT_freeSubtree(psFirstNew);
505              return iStatus;
506           }
507
508           /* set up for next level */
509           Path_free(oPPrefix);
510           psCurr = psNewNode;
(gdb) list
511           ulNewNodes++;
512           if(psFirstNew == NULL)
513              psFirstNew = psCurr;
514           ulIndex++;
515        }
516
517        Path_free(oPPath);
518        /* update BDT state variables to reflect insertion */
519        if(psRoot == NULL)
520           psRoot = psFirstNew;
(gdb) list
521        ulCount += ulNewNodes;
522
523        return SUCCESS;
524     }
525
526     boolean BDT_contains(const char *pcPath) {
527        int iStatus;
528        struct node *psFound = NULL;
529
530        assert(pcPath != NULL);
(gdb) list
531
532        iStatus = BDT_findNode(pcPath, &psFound);
533        return (boolean) (iStatus == SUCCESS);
534     }
535
536
537     int BDT_rm(const char *pcPath) {
538        int iStatus;
539        struct node *psFound = NULL;
540
(gdb) list
541        assert(pcPath != NULL);
542
543        iStatus = BDT_findNode(pcPath, &psFound);
544
545        if(iStatus != SUCCESS)
546            return iStatus;
547
548        ulCount -= BDT_freeSubtree(psFound);
549        if(ulCount == 0)
550           psRoot = NULL;
(gdb) list
551
552        return SUCCESS;
553     }
554
555     int BDT_init(void) {
556
557        if(bIsInitialized)
558           return INITIALIZATION_ERROR;
559
560        bIsInitialized = TRUE;
(gdb) list
561        psRoot = NULL;
562        ulCount = 0;
563
564        return SUCCESS;
565     }
566
567     int BDT_destroy(void) {
568
569
570        if(!bIsInitialized)
(gdb) list
571           return INITIALIZATION_ERROR;
572
573        if(psRoot) {
574           ulCount -= BDT_freeSubtree(psRoot);
575           psRoot = NULL;
576        }
577
578        bIsInitialized = FALSE;
579
580        return SUCCESS;
(gdb) list
581     }
582
583
584     /* --------------------------------------------------------------------
585
586       The following auxiliary functions are used for generating the
587       string representation of the BDT.
588     */
589
590     /*
(gdb) list
591       Performs a pre-order traversal of the tree rooted at psNode,
592       inserting each payload into oDNodes beginning at index ulIndex.
593       Returns the next unused index in d after the insertion(s).
594     */
595     static size_t BDT_preOrderTraversal(struct node *psNode,
596                                         DynArray_T oDNodes,
597                                         size_t ulIndex) {
598        size_t c;;
599
600        assert(oDNodes != NULL);
(gdb) list
601        /* psNode may be NULL, e.g. recursive call from leaf, guard below */
602
603        if(psNode != NULL) {
604           (void) DynArray_set(oDNodes, ulIndex, psNode);
605           ulIndex++;
606           for(c = 0; c < BDT_getNumChildren(psNode); c++) {
607              int iStatus;
608              struct node *psChild = NULL;
609              iStatus = BDT_getChild(psNode, c, &psChild);
610              assert(iStatus == SUCCESS);
(gdb) list
611              ulIndex = BDT_preOrderTraversal(psChild, oDNodes, ulIndex);
612           }
613        }
614        return ulIndex;
615     }
616
617     /*
618       Alternate version of strlen that uses pulAcc as an in-out parameter
619       to accumulate a string length, rather than returning the length of
620       psNode's path, and also always adds one addition byte to the sum.
(gdb) list
621     */
622     static void BDT_strlenAccumulate(struct node *psNode, size_t *pulAcc) {
623        assert(pulAcc != NULL);
624        /* psNode can be NULL -- guarded below */
625
626        if(psNode != NULL)
627           *pulAcc += (Path_getStrLength(BDT_getPath(psNode)) + 1);
628     }
629
630     /*
(gdb) list
631       Alternate version of strcat that inverts the typical argument
632       order, appending psNode's path onto pcAcc, and also always adds one
633       newline at the end of the concatenated string.
634     */
635     static void BDT_strcatAccumulate(struct node *psNode, char *pcAcc) {
636        assert(pcAcc != NULL);
637        /* psNode can be NULL -- guarded below */
638
639        if(psNode != NULL) {
640           strcat(pcAcc, Path_getPathname(BDT_getPath(psNode)));
(gdb) list
641           strcat(pcAcc, "\n");
642        }
643     }
644     /*--------------------------------------------------------------------*/
645
646     char *BDT_toString(void) {
647        DynArray_T nodes;
648        size_t totalStrlen = 1;
649        char *result = NULL;
650
(gdb) list
651        if(!bIsInitialized)
652           return NULL;
653
654        nodes = DynArray_new(ulCount);
655        (void) BDT_preOrderTraversal(psRoot, nodes, 0);
656
657        DynArray_map(nodes, (void (*)(void *, void*)) BDT_strlenAccumulate,
658                     (void*) &totalStrlen);
659
660        result = malloc(totalStrlen);
(gdb) list
661        if(result == NULL) {
662           DynArray_free(nodes);
663           return NULL;
664        }
665        *result = '\0';
666
667        DynArray_map(nodes, (void (*)(void *, void*)) BDT_strcatAccumulate,
668                     (void *) result);
669
670        DynArray_free(nodes);
(gdb) list
671
672        return result;
673     }