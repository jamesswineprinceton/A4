1       /*--------------------------------------------------------------------*/
2       /* bdt.c (3rd bad version)                                            */
3       /* Author: Christopher Moretti                                        */
4       /*--------------------------------------------------------------------*/
5
6       #include <stddef.h>
7       #include <assert.h>
8       #include <string.h>
9       #include <stdio.h>
10      #include <stdlib.h>
(gdb) ls
Undefined command: "ls".  Try "help".
(gdb) list
11
12      #include "dynarray.h"
13      #include "path.h"
14      #include "bdt.h"
15
16
17      /* A node in a BDT */
18      struct node {
19         /* the object corresponding to the node's absolute path */
20         Path_T oPPath;
(gdb) list
21         /* this node's parent */
22         struct node *psParent;
23         /* this node's children */
24         struct node *psChild1, *psChild2;
25      };
26
27      /*
28        A Directory Tree is a representation of a hierarchy of directories,
29        represented as an AO with 3 state variables:
30      */
(gdb) list
31
32      /* 1. a flag for being in an initialized state (TRUE) or not (FALSE) */
33      static boolean bIsInitialized;
34      /* 2. a pointer to the root node in the hierarchy */
35      static struct node *psRoot;
36      /* 3. a counter of the number of nodes in the hierarchy */
37      static size_t ulCount;
38
39      /*
40        Links new child psChild from psParent. If psParent already has
(gdb) list
41        two children, returns CONFLICTING_PATH, otherwise returns SUCCESS.
42      */
43      static int BDT_addChild(struct node *psParent, struct node *psChild) {
44         assert(psParent != NULL);
45         assert(psChild != NULL);
46
47         if(!psParent->psChild1)
48            psParent->psChild1 = psParent->psChild1;
49         else if(!psParent->psChild2)
50            psParent->psChild2 = psParent->psChild2;
(gdb) list
51         else
52            return CONFLICTING_PATH;
53
54         return SUCCESS;
55      }
56
57      /*
58        Compares the string representation of psfirst with a string
59        pcSecond representing a node's path.
60        Returns <0, 0, or >0 if psFirst is "less than", "equal to", or
(gdb) list
61        "greater than" pcSecond, respectively.
62      */
63      static int BDT_compareNodeToString(const struct node *psFirst,
64                                       const char *pcSecond) {
65         assert(psFirst != NULL);
66         assert(pcSecond != NULL);
67
68         return Path_compareString(psFirst->oPPath, pcSecond);
69      }
70
(gdb) list
71      /* Returns the number of children that psParent has. */
72      static size_t BDT_getNumChildren(struct node *psParent) {
73         assert(psParent != NULL);
74
75         return (size_t) (2 - (!psParent->psChild1 + !psParent->psChild2));
76      }
77
78      /*
79        Returns TRUE if psParent has a child with path oPPath. Returns
80        FALSE if it does not.
(gdb) list
81
82        If psParent has such a child, stores in *pulChildID the child's
83        identifier (as used in BDT_getChild). If psParent does not have
84        such a child, stores in *pulChildID the identifier that such a
85        child _would_ have if inserted.
86      */
87      static boolean BDT_hasChild(struct node *psParent, Path_T oPPath,
88                               size_t *pulChildID) {
89         assert(psParent != NULL);
90         assert(oPPath != NULL);
(gdb) list
91         assert(pulChildID != NULL);
92
93         if(!psParent->psChild1) {
94            *pulChildID = 0;
95            return FALSE;
96         }
97         else if(!BDT_compareNodeToString(psParent->psChild1,
98                                     Path_getPathname(oPPath))) {
99            *pulChildID = 0;
100           return TRUE;
(gdb) list
101        }
102        else if(!psParent->psChild2) {
103           *pulChildID = 1;
104           return FALSE;
105        }
106        else if(!BDT_compareNodeToString(psParent->psChild2,
107                                    Path_getPathname(oPPath))) {
108           *pulChildID = 1;
109           return TRUE;
110        }
(gdb) list
111        else {
112           *pulChildID = 2;
113           return FALSE;
114        }
115     }
116
117
118     /*
119       Creates a new node with path oPPath and parent psParent.  Returns an
120       int SUCCESS status and sets *ppsResult to be the new node if
(gdb) list
121       successful. Otherwise, sets *ppsResult to NULL and returns status:
122       * MEMORY_ERROR if memory could not be allocated to complete request
123       * CONFLICTING_PATH if psParent's path is not an ancestor of oPPath
124                          or if psParent already has two children
125       * NO_SUCH_PATH if oPPath is of depth 0
126                      or psParent's path is not oPPath's direct parent
127                      or psParent is NULL but oPPath is not of depth 1
128       * ALREADY_IN_TREE if psParent already has a child with this path
129     */
130     static int BDT_newNode(Path_T oPPath, struct node *psParent, struct node **ppsResult) {
(gdb) list
131        struct node *psNew;
132        Path_T oPParentPath = NULL;
133        Path_T oPNewPath = NULL;
134        size_t ulParentDepth;
135        size_t ulIndex;
136        int iStatus;
137
138        assert(oPPath != NULL);
139        assert(ppsResult != NULL);
140        /* psParent may be NULL -- when the new node is the root */
(gdb) list
141
142        /* allocate space for a new node */
143        psNew = malloc(sizeof(struct node));
144        if(psNew == NULL) {
145           *ppsResult = NULL;
146           return MEMORY_ERROR;
147        }
148
149        /* set the new node's path */
150        iStatus = Path_dup(oPPath, &oPNewPath);
(gdb) list
151        if(iStatus != SUCCESS) {
152           free(psNew);
153           *ppsResult = NULL;
154           return iStatus;
155        }
156        psNew->oPPath = oPNewPath;
157
158        /* validate and set the new node's parent */
159        if(psParent != NULL) {
160           size_t ulSharedDepth;
(gdb) list
161
162           oPParentPath = psParent->oPPath;
163           ulParentDepth = Path_getDepth(oPParentPath);
164           ulSharedDepth = Path_getSharedPrefixDepth(psNew->oPPath,
165                                                     oPParentPath);
166           /* parent must be an ancestor of child */
167           if(ulSharedDepth < ulParentDepth) {
168              Path_free(psNew->oPPath);
169              free(psNew);
170              *ppsResult = NULL;
(gdb) list
171              return CONFLICTING_PATH;
172           }
173
174           /* parent must be exactly one level up from child */
175           if(Path_getDepth(psNew->oPPath) != ulParentDepth + 1) {
176              Path_free(psNew->oPPath);
177              free(psNew);
178              *ppsResult = NULL;
179              return NO_SUCH_PATH;
180           }
(gdb) list
181
182           /* parent must not already have child with this path */
183           if(BDT_hasChild(psParent, oPPath, &ulIndex)) {
184              Path_free(psNew->oPPath);
185              free(psNew);
186              *ppsResult = NULL;
187              return ALREADY_IN_TREE;
188           }
189
190           /* parent must not already have two children */
(gdb) list
191           if(BDT_getNumChildren(psParent) == 2) {
192              Path_free(psNew->oPPath);
193              free(psNew);
194              *ppsResult = NULL;
195              return CONFLICTING_PATH;
196           }
197        }
198        else {
199           /* new node must be root */
200           /* can only create one "level" at a time */
(gdb) list
201           if(Path_getDepth(psNew->oPPath) != 1) {
202              Path_free(psNew->oPPath);
203              free(psNew);
204              *ppsResult = NULL;
205              return NO_SUCH_PATH;
206           }
207        }
208        psNew->psParent = psParent;
209
210        /* set the new node's children */
(gdb) list
211        psNew->psChild1 = NULL;
212        psNew->psChild2 = NULL;
213
214        /* Link into parent's child link */
215        if(psParent != NULL) {
216           iStatus = BDT_addChild(psParent, psNew);
217           if(iStatus != SUCCESS) {
218              Path_free(psNew->oPPath);
219              free(psNew);
220              *ppsResult = NULL;
(gdb) list
221              return iStatus;
222           }
223        }
224
225        *ppsResult = psNew;
226        return SUCCESS;
227     }
228
229     /*
230       Destroys and frees all memory allocated for the subtree rooted at
(gdb) list
231       psNode, i.e., deletes this node and all its descendents. Returns the
232       number of nodes deleted.
233     */
234     static size_t BDT_freeSubtree(struct node *psNode) {
235        size_t ulCount = 0;
236
237        assert(psNode != NULL);
238
239        /* remove from parent's list */
240        if(psNode->psParent != NULL) {
(gdb) list
241           if(psNode->psParent->psChild1 == psNode) {
242              psNode->psParent->psChild1 = psNode->psParent->psChild2;
243              psNode->psParent->psChild2 = NULL;
244           }
245           else if(psNode->psParent->psChild2 == psNode) {
246              psNode->psParent->psChild2 = NULL;
247           }
248           else {
249              assert(FALSE);
250           }
(gdb) list
251        }
252
253        /* recursively remove children */
254        if(psNode->psChild2)
255           ulCount += BDT_freeSubtree(psNode->psChild2);
256        if(psNode->psChild1)
257           ulCount += BDT_freeSubtree(psNode->psChild1);
258
259        /* remove path */
260        Path_free(psNode->oPPath);
(gdb) list
261
262        /* finally, free the struct node */
263        free(psNode);
264        ulCount++;
265        return ulCount;
266     }
267
268     /* Returns the path object representing psNode's absolute path. */
269     static Path_T BDT_getPath(struct node *psNode) {
270        assert(psNode != NULL);
(gdb) list
271
272        return psNode->oPPath;
273     }
274
275
276     /*
277       Returns an int SUCCESS status and sets *ppsResult to be the child
278       node of psParent with identifier ulChildID, if one exists.
279       Otherwise, sets *ppsResult to NULL and returns status:
280       * NO_SUCH_PATH if ulChildID is not a valid child for psParent
(gdb) list
281     */
282     static int  BDT_getChild(struct node *psParent, size_t ulChildID,
283                        struct node **ppsResult) {
284
285        assert(psParent != NULL);
286        assert(ppsResult != NULL);
287
288        if(ulChildID == 0) {
289           *ppsResult = psParent->psChild1;
290           if(*ppsResult) return SUCCESS;
(gdb) list
291           else return NO_SUCH_PATH;
292        }
293        else if(ulChildID == 1) {
294           *ppsResult = psParent->psChild2;
295           if(*ppsResult) return SUCCESS;
296           else return NO_SUCH_PATH;
297        }
298        else {
299           *ppsResult = NULL;
300           return NO_SUCH_PATH;
(gdb) list
301        }
302     }
303
304     /* --------------------------------------------------------------------
305
306       The BDT_traversePath and BDT_findNode functions modularize the common
307       functionality of going as far as possible down an BDT towards a path
308       and returning either the node of however far was reached or the
309       node if the full path was reached, respectively.
310     */
(gdb) list
311
312     /*
313       Traverses the BDT starting at the root as far as possible towards
314       absolute path oPPath. If able to traverse, returns an int SUCCESS
315       status and sets *ppsFurthest to the furthest node reached (which may
316       be only a prefix of oPPath, or even NULL if the root is NULL).
317       Otherwise, sets *ppsFurthest to NULL and returns with status:
318       * CONFLICTING_PATH if the root's path is not a prefix of oPPath
319       * MEMORY_ERROR if memory could not be allocated to complete request
320     */
(gdb) list
321     static int BDT_traversePath(Path_T oPPath, struct node **ppsFurthest) {
322        int iStatus;
323        Path_T oPPrefix = NULL;
324        struct node *psCurr;
325        struct node *psChild = NULL;
326        size_t ulDepth;
327        size_t i;
328        size_t ulChildID;
329
330        assert(oPPath != NULL);
(gdb) list
331        assert(ppsFurthest != NULL);
332
333        /* root is NULL -> won't find anything */
334        if(psRoot == NULL) {
335           *ppsFurthest = NULL;
336           return SUCCESS;
337        }
338
339        iStatus = Path_prefix(oPPath, 1, &oPPrefix);
340        if(iStatus != SUCCESS) {
(gdb) list
341           *ppsFurthest = NULL;
342           return iStatus;
343        }
344
345        if(Path_comparePath(BDT_getPath(psRoot), oPPrefix)) {
346           Path_free(oPPrefix);
347           *ppsFurthest = NULL;
348           return CONFLICTING_PATH;
349        }
350        Path_free(oPPrefix);
(gdb) list
351        oPPrefix = NULL;
352
353        psCurr = psRoot;
354        ulDepth = Path_getDepth(oPPath);
355        for(i = 2; i <= ulDepth; i++) {
356           iStatus = Path_prefix(oPPath, i, &oPPrefix);
357           if(iStatus != SUCCESS) {
358              *ppsFurthest = NULL;
359              return iStatus;
360           }
(gdb) list
361           if(BDT_hasChild(psCurr, oPPrefix, &ulChildID)) {
362              /* go to that child and continue with next prefix */
363              Path_free(oPPrefix);
364              oPPrefix = NULL;
365              iStatus = BDT_getChild(psCurr, ulChildID, &psChild);
366              if(iStatus != SUCCESS) {
367                 *ppsFurthest = NULL;
368                 return iStatus;
369              }
370              psCurr = psChild;
(gdb) list
371           }
372           else {
373              /* psCurr doesn't have child with path oPPrefix:
374                 this is as far as we can go */
375              break;
376           }
377        }
378
379        Path_free(oPPrefix);
380        *ppsFurthest = psCurr;
(gdb) list
381        return SUCCESS;
382     }
383
384     /*
385       Traverses the BDT to find a node with absolute path pcPath. Returns a
386       int SUCCESS status and sets *ppsResult to be the node, if found.
387       Otherwise, sets *ppsResult to NULL and returns with status:
388       * INITIALIZATION_ERROR if the BDT is not in an initialized state
389       * BAD_PATH if pcPath does not represent a well-formatted path
390       * CONFLICTING_PATH if the root's path is not a prefix of pcPath
(gdb) list
391       * NO_SUCH_PATH if no node with pcPath exists in the hierarchy
392       * MEMORY_ERROR if memory could not be allocated to complete request
393      */
394     static int BDT_findNode(const char *pcPath, struct node **ppsResult) {
395        Path_T oPPath = NULL;
396        struct node *psFound = NULL;
397        int iStatus;
398
399        assert(pcPath != NULL);
400        assert(ppsResult != NULL);
(gdb) list
401
402        if(!bIsInitialized) {
403           *ppsResult = NULL;
404           return INITIALIZATION_ERROR;
405        }
406
407        iStatus = Path_new(pcPath, &oPPath);
408        if(iStatus != SUCCESS) {
409           *ppsResult = NULL;
410           return iStatus;
(gdb) list
411        }
412
413        iStatus = BDT_traversePath(oPPath, &psFound);
414        if(iStatus != SUCCESS)
415        {
416           Path_free(oPPath);
417           *ppsResult = NULL;
418           return iStatus;
419        }
420
(gdb) list
421        if(psFound == NULL) {
422           Path_free(oPPath);
423           *ppsResult = NULL;
424           return NO_SUCH_PATH;
425        }
426
427        if(Path_comparePath(BDT_getPath(psFound), oPPath) != 0) {
428           Path_free(oPPath);
429           *ppsResult = NULL;
430           return NO_SUCH_PATH;
(gdb) list
431        }
432
433        Path_free(oPPath);
434        *ppsResult = psFound;
435        return SUCCESS;
436     }
437     /*--------------------------------------------------------------------*/
438
439
440     int BDT_insert(const char *pcPath) {
(gdb) list
441        int iStatus;
442        Path_T oPPath = NULL;
443        struct node *psFirstNew = NULL;
444        struct node *psCurr = NULL;
445        size_t ulDepth, ulIndex;
446        size_t ulNewNodes = 0;
447
448        assert(pcPath != NULL);
449
450        /* validate pcPath and generate a Path_T for it */
(gdb) list
451        if(!bIsInitialized)
452           return INITIALIZATION_ERROR;
453
454        iStatus = Path_new(pcPath, &oPPath);
455        if(iStatus != SUCCESS)
456           return iStatus;
457
458        /* find the closest ancestor of oPPath already in the tree */
459        iStatus= BDT_traversePath(oPPath, &psCurr);
460        if(iStatus != SUCCESS)
(gdb) list
461        {
462           Path_free(oPPath);
463           return iStatus;
464        }
465
466        /* no ancestor node found, so if root is not NULL,
467           pcPath isn't underneath root. */
468        if(psCurr == NULL && psRoot != NULL) {
469           Path_free(oPPath);
470           return CONFLICTING_PATH;
(gdb) list
471        }
472
473        ulDepth = Path_getDepth(oPPath);
474        if(psCurr == NULL) /* new root! */
475           ulIndex = 1;
476        else {
477           ulIndex = Path_getDepth(BDT_getPath(psCurr))+1;
478
479           /* psCurr is the node we're trying to insert */
480           if(ulIndex == ulDepth+1 && !Path_comparePath(oPPath,
(gdb) list
481                                            BDT_getPath(psCurr))) {
482              Path_free(oPPath);
483              return ALREADY_IN_TREE;
484           }
485        }
486
487        /* starting at psCurr, build rest of the path one level at a time */
488        while(ulIndex <= ulDepth) {
489           Path_T oPPrefix = NULL;
490           struct node *psNewNode = NULL;
(gdb) list
491
492           /* generate a Path_T for this level */
493           iStatus = Path_prefix(oPPath, ulIndex, &oPPrefix);
494           if(iStatus != SUCCESS) {
495              Path_free(oPPath);
496              if(psFirstNew != NULL)
497                 (void) BDT_freeSubtree(psFirstNew);
498              return iStatus;
499           }
500
(gdb) list
501           /* insert the new node for this level */
502           iStatus = BDT_newNode(oPPrefix, psCurr, &psNewNode);
503           if(iStatus != SUCCESS) {
504              Path_free(oPPath);
505              Path_free(oPPrefix);
506              if(psFirstNew != NULL)
507                 (void) BDT_freeSubtree(psFirstNew);
508              return iStatus;
509           }
510
(gdb) list
511           /* set up for next level */
512           Path_free(oPPrefix);
513           psCurr = psNewNode;
514           ulNewNodes++;
515           if(psFirstNew == NULL)
516              psFirstNew = psCurr;
517           ulIndex++;
518        }
519
520        Path_free(oPPath);
(gdb) list
521        /* update BDT state variables to reflect insertion */
522        if(psRoot == NULL)
523           psRoot = psFirstNew;
524        ulCount += ulNewNodes;
525
526        return SUCCESS;
527     }
528
529     boolean BDT_contains(const char *pcPath) {
530        int iStatus;
(gdb) list
531        struct node *psFound = NULL;
532
533        assert(pcPath != NULL);
534
535        iStatus = BDT_findNode(pcPath, &psFound);
536        return (boolean) (iStatus == SUCCESS);
537     }
538
539
540     int BDT_rm(const char *pcPath) {
(gdb) list
541        int iStatus;
542        struct node *psFound = NULL;
543
544        assert(pcPath != NULL);
545
546        iStatus = BDT_findNode(pcPath, &psFound);
547
548        if(iStatus != SUCCESS)
549            return iStatus;
550
(gdb) list
551        ulCount -= BDT_freeSubtree(psFound);
552        if(ulCount == 0)
553           psRoot = NULL;
554
555        return SUCCESS;
556     }
557
558     int BDT_init(void) {
559
560        if(bIsInitialized)
(gdb) list
561           return INITIALIZATION_ERROR;
562
563        bIsInitialized = TRUE;
564        psRoot = NULL;
565        ulCount = 0;
566
567        return SUCCESS;
568     }
569
570     int BDT_destroy(void) {
(gdb) list
571
572
573        if(!bIsInitialized)
574           return INITIALIZATION_ERROR;
575
576        if(psRoot) {
577           ulCount -= BDT_freeSubtree(psRoot);
578           psRoot = NULL;
579        }
580
(gdb) list
581        bIsInitialized = FALSE;
582
583        return SUCCESS;
584     }
585
586
587     /* --------------------------------------------------------------------
588
589       The following auxiliary functions are used for generating the
590       string representation of the BDT.
(gdb) list
591     */
592
593     /*
594       Performs a pre-order traversal of the tree rooted at psNode,
595       inserting each payload into oDNodes beginning at index ulIndex.
596       Returns the next unused index in d after the insertion(s).
597     */
598     static size_t BDT_preOrderTraversal(struct node *psNode,
599                                         DynArray_T oDNodes,
600                                         size_t ulIndex) {
(gdb) list
601        size_t c;;
602
603        assert(oDNodes != NULL);
604        /* psNode may be NULL, e.g. recursive call from leaf, guard below */
605
606        if(psNode != NULL) {
607           (void) DynArray_set(oDNodes, ulIndex, psNode);
608           ulIndex++;
609           for(c = 0; c < BDT_getNumChildren(psNode); c++) {
610              int iStatus;
(gdb) list
611              struct node *psChild = NULL;
612              iStatus = BDT_getChild(psNode, c, &psChild);
613              assert(iStatus == SUCCESS);
614              ulIndex = BDT_preOrderTraversal(psChild, oDNodes, ulIndex);
615           }
616        }
617        return ulIndex;
618     }
619
620     /*
(gdb) list
621       Alternate version of strlen that uses pulAcc as an in-out parameter
622       to accumulate a string length, rather than returning the length of
623       psNode's path, and also always adds one addition byte to the sum.
624     */
625     static void BDT_strlenAccumulate(struct node *psNode, size_t *pulAcc) {
626        assert(pulAcc != NULL);
627        /* psNode can be NULL -- guarded below */
628
629        if(psNode != NULL)
630           *pulAcc += (Path_getStrLength(BDT_getPath(psNode)) + 1);
(gdb) list
631     }
632
633     /*
634       Alternate version of strcat that inverts the typical argument
635       order, appending psNode's path onto pcAcc, and also always adds one
636       newline at the end of the concatenated string.
637     */
638     static void BDT_strcatAccumulate(struct node *psNode, char *pcAcc) {
639        assert(pcAcc != NULL);
640        /* psNode can be NULL -- guarded below */
(gdb) list
641
642        if(psNode != NULL) {
643           strcat(pcAcc, Path_getPathname(BDT_getPath(psNode)));
644           strcat(pcAcc, "\n");
645        }
646     }
647     /*--------------------------------------------------------------------*/
648
649     char *BDT_toString(void) {
650        DynArray_T nodes;
(gdb) list
651        size_t totalStrlen = 1;
652        char *result = NULL;
653
654        if(!bIsInitialized)
655           return NULL;
656
657        nodes = DynArray_new(ulCount);
658        (void) BDT_preOrderTraversal(psRoot, nodes, 0);
659
660        DynArray_map(nodes, (void (*)(void *, void*)) BDT_strlenAccumulate,
(gdb) list
661                     (void*) &totalStrlen);
662
663        result = malloc(totalStrlen);
664        if(result == NULL) {
665           DynArray_free(nodes);
666           return NULL;
667        }
668        *result = '\0';
669
670        DynArray_map(nodes, (void (*)(void *, void*)) BDT_strcatAccumulate,
(gdb) list
671                     (void *) result);
672
673        DynArray_free(nodes);
674
675        return result;
676     }

